# Feature Specification: Testing Environment Setup (Vitest + TDD) and Git Hooks

**Feature Branch**: `005-testing-environment`
**Created**: 2025-11-28
**Status**: Draft
**Input**: User description: "Implement P0.6.7 (Testing Environment Setup with Vitest + TDD) and P0.6.7.1 (Git Hooks Setup with Husky + lint-staged)"

_Note: Generated by `/speckit.specify` command per Constitutional Principle XV (SpecKit Workflow Compliance)_

## Clarifications

### Session 2025-11-28

- Q: Which mocking approach should be used for RPC calls? → A: Combined approach: `@wagmi/connectors` mock connector for wallet connections + Vitest's `vi.mock()` for RPC responses

## User Scenarios & Testing _(mandatory)_

### User Story 1 - Developer runs test suite locally (Priority: P1)

Developers need to run tests locally before committing to catch regressions early and ensure code quality.

**Why this priority**: Foundation for TDD workflow - without this, no testing is possible.

**Independent Test**: Can be fully tested by running `pnpm test` and verifying tests execute with coverage reporting, delivering immediate value to developers.

**Acceptance Scenarios**:

1. **Given** a developer has made code changes, **When** they run `pnpm test`, **Then** all tests execute and display pass/fail results
2. **Given** tests are running, **When** they complete, **Then** coverage report shows percentage for each file
3. **Given** coverage is below 80%, **When** tests finish, **Then** the command exits with error code 1
4. **Given** coverage is at or above 80%, **When** tests finish, **Then** the command exits with success code 0

---

### User Story 2 - Developer writes tests before implementation (TDD Red-Green-Refactor) (Priority: P1)

Developers need to write failing tests first, then make them pass, then refactor - the classic TDD cycle mandated by Constitutional Principle XVI.

**Why this priority**: Core TDD discipline - this is the workflow that ensures test-first development.

**Independent Test**: Can be tested by creating a new test file, writing a failing test, confirming it fails (red), implementing code to pass it (green), and refactoring while keeping tests green.

**Acceptance Scenarios**:

1. **Given** a new feature requirement, **When** developer writes test first, **Then** test fails (RED state)
2. **Given** a failing test, **When** developer implements minimal code to pass, **Then** test passes (GREEN state)
3. **Given** passing tests, **When** developer refactors code, **Then** tests remain passing
4. **Given** Vitest in watch mode, **When** developer saves test file, **Then** tests automatically re-run

---

### User Story 3 - Developer tests React components (Priority: P1)

Developers need to test React components using @testing-library/react to ensure UI behavior works correctly.

**Why this priority**: VoidPay has React components that need testing (InvoiceCard, PaymentFlow, etc.).

**Independent Test**: Can be tested by creating a component test file, rendering a component, and asserting on its behavior.

**Acceptance Scenarios**:

1. **Given** a React component, **When** developer renders it in a test, **Then** component mounts without errors
2. **Given** a rendered component, **When** developer queries DOM elements, **Then** testing-library queries work correctly
3. **Given** a component with user interactions, **When** developer simulates events, **Then** component state updates as expected

---

### User Story 4 - Developer tests schema encoding/decoding (Priority: P1)

Developers need snapshot tests for invoice schema and URL encoding to ensure backward compatibility (Constitutional Principle IV).

**Why this priority**: Critical for URL state model - old invoice URLs must work forever.

**Independent Test**: Can be tested by creating snapshot tests for schema v1 encoding/decoding and verifying they fail on breaking changes.

**Acceptance Scenarios**:

1. **Given** invoice schema v1 data, **When** developer runs snapshot test, **Then** encoded output matches saved snapshot
2. **Given** encoded invoice URL, **When** developer runs decoding test, **Then** decoded data matches original input
3. **Given** schema structure changes, **When** developer runs tests, **Then** snapshot test fails alerting to breaking change

---

### User Story 5 - Developer mocks Web3 RPC calls (Priority: P1)

Developers need to mock RPC calls (Alchemy/Infura) in tests without hitting real networks or testnets.

**Why this priority**: Constitutional requirement - no testnet in CI (Principle XVI), and tests must be fast and reliable.

**Independent Test**: Can be tested by writing a test that calls Web3 functionality, verifying the RPC call is mocked, and confirming no network request is made.

**Acceptance Scenarios**:

1. **Given** code that calls RPC endpoint, **When** test runs, **Then** RPC call is intercepted by mock
2. **Given** mocked RPC response, **When** code processes it, **Then** behavior matches real RPC response format
3. **Given** test suite runs in CI, **When** Web3 tests execute, **Then** no actual network requests are made

---

### User Story 6 - Developer commits code with pre-commit validation (Priority: P2)

Developers need automatic lint and type-check on staged files before commit to catch errors early.

**Why this priority**: Prevents broken code from entering git history, enforcing quality at commit time.

**Independent Test**: Can be tested by staging files with lint/type errors and attempting to commit, verifying the commit is blocked.

**Acceptance Scenarios**:

1. **Given** staged files with lint errors, **When** developer runs `git commit`, **Then** pre-commit hook runs lint-staged
2. **Given** lint errors detected, **When** hook completes, **Then** commit is blocked with error message
3. **Given** all staged files pass lint and type-check, **When** developer commits, **Then** commit succeeds
4. **Given** pre-commit hook running, **When** checking files, **Then** only staged files are checked (not entire codebase)

---

### User Story 7 - Developer pushes code with full test validation (Priority: P2)

Developers need full test suite with coverage check before push to ensure quality code reaches remote.

**Why this priority**: Final quality gate before code is shared - prevents pushing untested/failing code.

**Independent Test**: Can be tested by attempting to push with failing tests or <80% coverage and verifying push is blocked.

**Acceptance Scenarios**:

1. **Given** local commits ready to push, **When** developer runs `git push`, **Then** pre-push hook runs full test suite
2. **Given** any test fails, **When** hook completes, **Then** push is blocked with error message
3. **Given** coverage below 80%, **When** tests complete, **Then** push is blocked with coverage error
4. **Given** all tests pass with ≥80% coverage, **When** developer pushes, **Then** push succeeds

---

### User Story 8 - CI/CD pipeline validates code quality (Priority: P2)

Continuous integration must run tests and block merges on failures to maintain main branch quality.

**Why this priority**: Protects main branch from broken code, ensures all merged code is tested.

**Independent Test**: Can be tested by creating a PR with failing tests and verifying CI blocks the merge.

**Acceptance Scenarios**:

1. **Given** a pull request, **When** CI runs, **Then** test suite executes automatically
2. **Given** tests fail in CI, **When** checking PR status, **Then** merge is blocked
3. **Given** coverage below threshold, **When** CI completes, **Then** PR status shows failure
4. **Given** all tests pass with sufficient coverage, **When** CI completes, **Then** PR can be merged

---

### Edge Cases

- What happens when developer bypasses hooks with `--no-verify` flag? (Document that this violates Constitutional Principle XVI and should never be done)
- How does system handle very slow tests (>2 minutes)? (Pre-push hook should have reasonable timeout, tests should be optimized)
- What happens when lint-staged processes non-text binary files? (Glob patterns should exclude binaries)
- How does coverage calculation handle generated files? (Coverage config should exclude build artifacts, node_modules)
- What happens when snapshot tests fail in CI but pass locally? (Indicates environmental difference - snapshots should be platform-agnostic)
- How does system handle flaky tests that pass/fail intermittently? (Tests must be deterministic - flaky tests are bugs to fix)

## Requirements _(mandatory)_

### Functional Requirements

#### Testing Environment (P0.6.7)

- **FR-001**: System MUST install Vitest version 3.x or higher as test runner
- **FR-002**: System MUST install @testing-library/react for component testing
- **FR-003**: System MUST configure coverage threshold at 80% minimum
- **FR-004**: System MUST fail builds when coverage drops below threshold
- **FR-005**: System MUST provide `pnpm test` command to run full test suite
- **FR-006**: System MUST provide `pnpm test:coverage` command to generate coverage reports
- **FR-007**: System MUST provide `pnpm test:watch` command for watch mode during development
- **FR-008**: System MUST provide Web3 mocking utilities: `import { mock } from '@wagmi/connectors'` for wallet connections/signing simulation, and Vitest's `vi.mock()` for RPC responses - avoiding network calls in tests
- **FR-009**: System MUST support snapshot testing for schema versioning and URL encoding
- **FR-010**: System MUST exclude node_modules, build artifacts, and generated files from coverage calculation
- **FR-011**: System MUST generate HTML coverage reports in `coverage/` directory
- **FR-012**: System MUST support testing TypeScript files without compilation errors

#### Git Hooks (P0.6.7.1)

- **FR-013**: System MUST install Husky for git hook management
- **FR-014**: System MUST install lint-staged for staged file processing
- **FR-015**: System MUST configure pre-commit hook to run on `git commit`
- **FR-016**: Pre-commit hook MUST run ESLint on staged TypeScript/JavaScript files
- **FR-017**: Pre-commit hook MUST run TypeScript type-checking on the project (note: `tsc --noEmit` cannot check staged files only; full project check is acceptable given codebase size)
- **FR-018**: Pre-commit hook MUST block commit if lint errors are detected
- **FR-019**: Pre-commit hook MUST block commit if type errors are detected
- **FR-020**: System MUST configure pre-push hook to run on `git push`
- **FR-021**: Pre-push hook MUST run full test suite with coverage
- **FR-022**: Pre-push hook MUST block push if any tests fail
- **FR-023**: Pre-push hook MUST block push if coverage is below 80%
- **FR-024**: Hooks MUST be automatically installed when running `pnpm install`
- **FR-025**: System MUST provide clear error messages when hooks block operations

#### Integration Requirements

- **FR-026**: Testing configuration MUST align with Constitutional Principle XVI (TDD Discipline)
- **FR-027**: System MUST support co-located tests in `__tests__/` directories
- **FR-028**: System MUST support test file naming pattern `*.test.ts` and `*.test.tsx`
- **FR-029**: Coverage reports MUST be excluded from git via `.gitignore`
- **FR-030**: CI environment MUST run same test suite as local development

### Key Entities _(include if feature involves data)_

- **Test Suite**: Collection of unit, component, and snapshot tests that validate code correctness
- **Coverage Report**: Metrics showing percentage of code covered by tests (lines, branches, functions, statements)
- **Git Hook**: Script that runs automatically before git operations (commit, push) to enforce quality checks
- **Snapshot**: Saved test output used to detect unintended changes in schema, URLs, or component rendering
- **Mock**: Simulated Web3 responses - two types: (1) `import { mock } from '@wagmi/connectors'` for wallet connection, signing, chain switching; (2) Vitest `vi.mock()` for RPC responses (balances, transactions)

## Success Criteria _(mandatory)_

### Measurable Outcomes

- **SC-001**: Developers can run full test suite locally with `pnpm test` in under 60 seconds
- **SC-002**: Test coverage is automatically measured and reported for every test run
- **SC-003**: Commits with lint errors are blocked 100% of the time (when hooks are not bypassed)
- **SC-004**: Pushes with test failures or <80% coverage are blocked 100% of the time (when hooks are not bypassed)
- **SC-005**: Developers receive clear error messages within 5 seconds when quality checks fail
- **SC-006**: 100% of invoice schema changes are caught by snapshot tests before breaking old URLs
- **SC-007**: 0% of tests make actual network requests (all RPC calls mocked)
- **SC-008**: CI pipeline runs same tests as local environment with identical pass/fail results
- **SC-009**: Test configuration setup takes less than 5 minutes after running `pnpm install`
- **SC-010**: 95%+ of tests complete within 10 seconds each (fast feedback for TDD red-green cycles)

## Dependencies

- **Depends On**: P0.1 (Repository Setup) - requires existing Next.js + TypeScript + pnpm setup
- **Blocks**: P0.6.7.1 (Git Hooks) depends on P0.6.7 (Testing Environment)
- **Blocks**: All future development features require this testing infrastructure per Constitutional Principle XVI

## Assumptions

- Project already has ESLint and TypeScript configured (from P0.1)
- Project uses pnpm as package manager (per constitution)
- Developers have Node.js 20+ installed (per constitution)
- Git repository is already initialized
- Project follows Feature-Sliced Design architecture
- Vitest is compatible with Next.js 16.0.3+ and React 19+
- Snapshot tests will use Vitest's built-in snapshot functionality
- Web3 mocking will use combined approach: `@wagmi/connectors` mock connector for wallet interactions + Vitest's `vi.mock()` for RPC responses

## Notes

- Constitutional Principle XVI mandates TDD discipline: Red → Green → Refactor
- No testnet calls in CI - all Web3 tests must use mocks
- Snapshot tests are critical for backward compatibility (Principle IV)
- Coverage threshold (80%) is non-negotiable per constitution
- Git hooks can be bypassed with `--no-verify` but this violates Principle XVI
- This feature enables parallel development of all other features by providing quality gates

<!--
  SYNC IMPACT REPORT

  Version Change: 1.8.0 ‚Üí 1.9.0

  Modified Principles: None

  Added Sections:
  - XIV. Serena Memory as Project Knowledge Repository (mandatory use of .serena/memories/ as source of truth)
  - XV. SpecKit Workflow Compliance (mandatory /speckit.* workflow for all feature development)

  Removed Sections: None

  Optimization Changes:
  - Streamlined principle explanations (removed verbose language)
  - Added cross-references between related principles
  - Consolidated duplicate guidance across principles

  Templates Requiring Updates:
  - .specify/templates/plan-template.md (‚ö† pending - add Principles XIV & XV to Constitution Check)
  - .specify/templates/spec-template.md (‚ö† pending - add Principle XV reference)
  - .specify/templates/tasks-template.md (‚ö† pending - add Principle XV reference)
  - CLAUDE.md (‚ö† pending - reference Principles XIV & XV in Workflow and Serena sections)

  Follow-up TODOs:
  - Update plan-template.md Constitution Check: Add "Serena memories consulted (XIV)" and "SpecKit workflow followed (XV)"
  - Update spec-template.md header: Add note "Generated by /speckit.specify per Principle XV"
  - Update tasks-template.md: Reference Principle XV workflow compliance
  - Update CLAUDE.md Workflow section: Link to Principle XV
  - Update CLAUDE.md Serena section: Link to Principle XIV

  Ratification: Adding Principles XIV and XV to establish Serena memories as mandatory knowledge repository and codify SpecKit workflow as constitutional requirements. These principles formalize best practices already recommended in CLAUDE.md, ensuring consistent agent behavior and knowledge management.
  Date: 2025-11-28
-->

# VoidPay Constitution

## Core Principles

### I. Zero-Backend Architecture (Stateless First)

**Principle**: The application MUST operate without a backend database or persistent server-side state for user data. All invoice data is encoded in URLs or stored client-side.

**Rules**:

- NO server-side database for storing invoice data
- NO user authentication or session management
- Invoice state MUST be self-contained in compressed URL parameters
- Client-side storage (LocalStorage) is permitted for user preferences and history only
- Server-side components are limited to: static hosting, RPC proxying, and OG image generation
- **Exception**: Transient operational storage (e.g., Redis/KV) is permitted for infrastructure state only:
  - Rate limiting counters (short TTL, no user data)
  - RPC response caching (ephemeral, no PII)
  - Operational metrics (anonymous, aggregated)
  - MUST NOT store user-identifiable data or invoice contents
  - MUST have explicit TTL and automatic expiration
  - MUST be justified in feature plan's Complexity Tracking table

**Rationale**: Ensures perpetual availability. Even if hosting is discontinued, the service can be instantly redeployed anywhere, including IPFS or local deployment. Users retain full control and ownership of their invoice data through self-contained URLs.

### II. Privacy-First & Self-Custody

**Principle**: User financial data MUST remain private and under user control at all times.

**Rules**:

- NO collection of analytics or telemetry about invoice creation or payments
- NO tracking of user behavior or payment patterns
- History MUST be stored exclusively in browser LocalStorage (never server-side)
- NO third-party analytics services (no Sentry, no Google Analytics)
- URL parameters MUST NOT leak through server logs (use client-side URL parsing)
- Export/import functionality MUST be provided for user data portability

**Rationale**: Financial privacy is a fundamental right. Centralized storage of transaction history creates honeypots for data breaches and enables surveillance. Users must have complete autonomy over their financial records.

### III. Trustless & Permissionless

**Principle**: The system MUST NOT require permission, registration, or trust in any centralized authority.

**Rules**:

- NO user registration or account creation
- NO KYC (Know Your Customer) requirements
- NO approval workflows or administrative gates
- Users MUST be able to create invoices without providing any personal information
- Payments MUST occur directly between parties (peer-to-peer) without intermediaries
- NO custody of user funds at any time

**Rationale**: Permissionless access is core to the crypto ethos. Any gating mechanism creates censorship opportunities and excludes users. True decentralization requires removing all trusted intermediaries.

### IV. Backward Compatibility & Schema Versioning

**Principle**: Once an invoice URL is generated, it MUST remain functional indefinitely regardless of future application changes.

**Rules**:

- Schema version (`v` field) MUST be embedded in every invoice URL
- Parsing logic for schema version N MUST NEVER be modified or removed
- New schema versions MUST be additive only (new versions = new parsers)
- Migration adapters MUST convert old schemas to new formats at runtime for display
- Reserved fields (`meta`, `_future`) MUST be included in schema v1 for extensibility
- URL compression format MUST remain stable (lz-string algorithm locked)
- Breaking changes require new schema version with migration adapter

**Rationale**: Following the Excalidraw model, breaking old URLs destroys user trust and creates data loss. Invoice URLs may be stored in emails, contracts, or bookmarks for years. Immutability of old versions is non-negotiable.

### V. Security & Abuse Prevention

**Principle**: The system MUST implement defense mechanisms against abuse while preserving privacy and permissionlessness.

**Rules**:

- Static blocklist MUST be maintained via public GitHub repository
- Blocklist MUST hash full URL parameters (SHA-256 of `?d=...`) to preserve privacy
- Blocklist updates MUST be transparent (public Pull Requests)
- "Report Abuse" functionality MUST be prominently displayed
- OFAC sanctions checking is explicitly prohibited in MVP (preserving permissionless philosophy)
- Disclaimers MUST clarify non-custodial nature and liability limits
- SEO indexing MUST be blocked on `/pay` and `/create` routes (X-Robots-Tag: noindex)
- Only landing page (`/`) should be indexed by search engines

**Rationale**: Abuse (phishing, scams) poses reputational and legal risks that could lead to domain blacklisting. However, mitigation MUST NOT compromise core principles. Blocklist via GitHub provides transparency, community moderation, and privacy preservation.

### VI. RPC Key Protection & Rate Limit Management

**Principle**: RPC provider API keys MUST be protected from exposure and abuse while maintaining decentralization.

**Rules**:

- RPC keys MUST be stored server-side in environment variables (never in client code)
- Edge Functions/API Routes MUST act as proxy between client and RPC providers
- Multiple RPC providers MUST be configured with automatic failover (Wagmi config)
- Primary provider: Alchemy (speed, Transfers API integration)
- Fallback provider: Infura (reliability, SLA guarantees)
- Static data (decimals, token symbols) MUST be cached aggressively (React Query `staleTime: Infinity`)
- Rate limiting MUST be implemented at proxy level to prevent abuse
- NO telemetry from proxy layer (privacy-first)

**Rationale**: Exposing RPC keys in client code leads to inevitable abuse and service disruption. Serverless proxy balances security with stateless architecture. Multi-provider failover ensures reliability. Aggressive caching minimizes RPC costs while maintaining decentralization.

### VII. Web3 Safety & Transaction Validation

**Principle**: All blockchain interactions MUST be validated for correctness and safety before execution.

**Rules**:

- Token decimals MUST be "baked" into URL at creation time (snapshot approach)
- Token addresses MUST be validated against Uniswap Token List
- Unknown tokens MUST display warning: "Unknown Token. Verify contract address carefully"
- Blue chip tokens (USDC, USDT, DAI, WETH) MUST show verified status (green checkmark)
- Network switching MUST be user-initiated ("Switch to Arbitrum" button), not automatic
- Transaction confirmation MUST wait for `finalized` status:
  - Ethereum: ~15 minutes (2 epochs)
  - Arbitrum/Optimism: ~10-15 minutes
  - Polygon PoS: ~30-45 minutes
- Payment verification MUST use exact amount matching (Magic Dust ensures uniqueness)
- NO reliance on fuzzy matching or tolerance thresholds
- Disclaimers MUST clarify direct peer-to-peer nature and irreversibility
- **Donation Strategy**:
  - Post-payment widget MUST use **Native Currency** only (single-click, no approval)
  - Footer "Support" modal MAY support ERC20 tokens (standard approval flow)
- **Transaction Discovery**:
  - Payer MUST store `txHash` in LocalStorage immediately upon signing
  - Creator MUST discover `txHash` via background polling (Alchemy Transfers API)
  - `txHash` MUST NOT be stored in the Invoice URL (keeps URL static)

**Rationale**: Cryptocurrency transactions are irreversible. Any error in decimals, addresses, or amounts results in permanent loss. Baking decimals into URLs eliminates RPC dependency and prevents decimal mismatch attacks. Finalized confirmations protect recipients from chain reorganizations. Magic Dust provides deterministic payment verification without backend.

### VIII. Documentation Context Efficiency

**Principle**: All project documentation MUST prioritize information density and context efficiency for AI agent consumption.

**Rules**:

- Markdown files loaded into agent context MUST be concise and information-dense
- Eliminate redundancy, filler language, and verbose explanations
- Use structured formats (lists, tables, code blocks) over prose paragraphs where appropriate
- Specification documents MUST focus on requirements, not implementation details
- Technical decisions MUST be documented with "Why" not "How" (code shows "how")
- Maximum file length targets (soft limits):
  - spec.md: <400 lines (focus on user stories and requirements)
  - plan.md: <300 lines (technical approach, not implementation steps)
  - tasks.md: Task list only, minimal prose
  - research.md: <200 lines (key findings, links to external resources)
- Use abbreviated keys in JSON schemas (e.g., `iss` not `issueDate`) to reduce URL payload
- Cross-reference external documentation via links rather than duplicating content
- Templates MUST be concise with inline guidance, not separate documentation sections

**Rationale**: AI agents have context windows that fill quickly. Verbose documentation wastes tokens, slows processing, and reduces the amount of relevant code/context that can be loaded. Information-dense documentation enables agents to understand the project faster and make better decisions. See Principles XIII and XIV for code navigation and knowledge repository efficiency requirements.

### IX. Implementation Deviation Tracking & Feedback Loop

**Principle**: Implementation reality MUST be systematically tracked and fed back into planning artifacts to maintain alignment between design and code.

**Rules**:

- When marking tasks as complete, agents MUST record any deviations from the planned implementation
- Deviations MUST be documented with:
  - What was planned (reference to plan.md, spec.md, or data-model.md)
  - What was actually implemented
  - Rationale for the deviation (technical constraints, better approach discovered, requirements changed)
  - Impact assessment (breaking changes, performance implications, security considerations)
- Deviation notes MUST be recorded in tasks.md adjacent to the completed task checkbox
- Upon completing a feature or significant milestone, agents MUST update the relevant `ROADMAP_P*.md` file with:
  - Feature completion status (üü¢ **Completed**: YYYY-MM-DD)
  - **Feature Folder**: Path to the spec folder (e.g., `specs/002-url-state-codec/`)
  - **Implemented**: Brief implementation summary (what was built)
  - **Deviations**: Key deviations from original plan (if any)
  - **Notes**: Technical decisions or constraints encountered
- ROADMAP updates MUST follow the "How to Log Progress" instructions in `ROADMAP.md`
- After feature completion, accumulated deviations MUST be reviewed to determine:
  - Whether spec.md needs updating (requirements changed)
  - Whether plan.md needs updating (approach changed)
  - Whether data-model.md needs updating (schema evolved)
  - Whether constitution.md needs updating (new constraints discovered)
- Major deviations (breaking changes, architectural shifts) MUST trigger immediate artifact updates
- Minor deviations (implementation details, optimizations) MAY be batched for end-of-feature review
- Task completion format MUST include deviation field: `- [x] T001 [Description] | Deviation: [None | <deviation description>]`

**Rationale**: Plans are hypotheses that collide with reality during implementation. Without systematic tracking of what actually happened versus what was planned, design artifacts become stale and misleading. By capturing deviations at task completion time, we create a continuous improvement cycle that keeps specifications, plans, and reality aligned.

### X. Git Worktree Isolation for Concurrent Development

**Principle**: Each feature MUST be developed in an isolated Git worktree to prevent conflicts between concurrent agents and enable parallel development.

**Rules**:

- Every feature specification MUST be developed in a dedicated Git worktree
- Worktree naming convention: `worktrees/###-feature-name` (matching feature branch name)
- Feature branch MUST be created before worktree: `git branch ###-feature-name`
- Worktree creation: `git worktree add worktrees/###-feature-name ###-feature-name`
- Agents MUST work exclusively within their assigned worktree directory
- NO cross-worktree file modifications (each agent owns one worktree)
- Main worktree (repository root) is reserved for integration and release work only
- Feature worktrees MUST be removed after feature completion and branch merge: `git worktree remove worktrees/###-feature-name`
- Worktree cleanup MUST be verified: `git worktree prune`
- Specification artifacts (specs/###-feature-name/) MUST be committed in feature worktree before integration
- Integration to main branch MUST happen via rebase or merge from feature worktree
- Concurrent features (e.g., 001-feature-a, 002-feature-b) MUST use separate worktrees to avoid conflicts

**Rationale**: Git worktrees enable true parallel development by creating separate working directories for each feature branch while sharing the same Git repository. This prevents file-level conflicts when multiple agents work on different features simultaneously. Without worktrees, concurrent agents would compete for the same working directory, causing constant context switching, merge conflicts, and lost work.

### XI. Design Fidelity & V0 Integration

**Principle**: All UI implementation MUST be strictly based on the V0 design assets located in `assets/v0`. Agents MUST NOT invent designs and MUST ask for clarification if assets are missing.

**Rules**:

- **Source of Truth**: The `assets/v0` directory is the absolute source of truth for all visual design.
- **Component Library**: Agents MUST use `@radix-ui/react-*` components (via shadcn/ui) as the foundation.
- **Strict Fidelity**: Implementations MUST match the V0 design reference pixel-perfectly unless explicitly instructed otherwise.
- **Agent Responsibility**:
  - Agents MUST search `assets/v0` for the relevant design file before implementation.
  - If a design element is missing, agents MUST ask the user for guidance, NOT invent a solution.
  - Agents MUST NOT deviate from the V0 design without explicit user approval.

**Rationale**: V0 assets represent the approved design vision. Inventing designs leads to inconsistency and drift from the product vision. Strict adherence ensures a cohesive and premium user experience.

### XII. UI/UX Design Principles

**Principle**: The application MUST maintain a consistent visual identity that reinforces the metaphor of "paper on a desk" while ensuring print/PDF fidelity.

**Rules**:

#### 12.1 Theme: Hybrid Theme Strategy

- **App UI (Controls/Layout)**: Deep Dark Mode using `zinc-950` background ("The Desk")
- **Document Surface (Invoice)**: Light Mode using `white` background ("The Paper")
- This dual-theme approach MUST be maintained consistently across all views
- Navigation, toolbars, sidebars, and controls MUST use dark theme colors
- Invoice preview/display components MUST use light theme colors
- NO full-app light mode or full-app dark mode toggle (hybrid is mandatory)

#### 12.2 Visual Physics: ISO 216 Compliance

- All document representations MUST strictly follow ISO 216 (A4) aspect ratio: `1:1.414`
- This applies to: invoice preview components, PDF generation output, print layouts, any visual representation of the invoice document
- Aspect ratio MUST be enforced in CSS/layout calculations
- Deviations from 1:1.414 ratio are NOT permitted (ensures print/PDF consistency)

#### 12.3 Palette: White Paper on Dark Desk

- **Primary Contrast**: White invoice card (`#FFFFFF` or `white`) on dark background (`zinc-950`)
- **Invoice Card Styling**: Background `white`, text/content black ink, subtle shadow for depth
- **Dark Desk Styling**: Background `zinc-950`, UI controls with light text
- **Accessibility**: MUST maintain WCAG AA contrast ratios (‚â•4.5:1 for both invoice content and UI controls)

#### 12.4 Editor UI: Layout Constraints

**Layout**:
- Application container MUST enforce `max-w-[1600px]` to prevent ultrawide stretching
- Container MUST be centered on viewport
- Responsive breakpoints MUST maintain aspect ratio integrity for invoice preview
- NO full-width layouts that distort the "desk" metaphor

**Preview Component**:
- MUST simulate an A4 sheet with shadow effect (`shadow-2xl`)
- MUST be centered on the dark background
- Optional: Subtle border (`border border-zinc-200`) for definition
- Preview MUST scale proportionally on smaller viewports while maintaining 1:1.414 ratio
- Preview MUST NOT exceed container width minus appropriate padding

#### 12.5 App Shell Architecture (The Desk vs. The Paper)

- **Structure**: Application MUST use an "App Shell" wrapper for `/create` and `/pay` routes
- **Header (The Desk)**: MUST contain VoidPay Logo (Branding) and Action Triggers (Menu, Wallet), visually distinct from invoice content
- **Footer (The Desk)**: MUST contain Trust & Safety elements (Report Abuse, Legal Disclaimer), visually distinct
- **Invoice Card (The Paper)**: MUST contain ONLY invoice data and "Powered by VoidPay" watermark, MUST NOT contain platform-level actions inside the card boundary
- **Receipt Mode**: Upon payment confirmation, MUST visually transform (PAID badge, Tx details)
- **PDF Generation**:
  - **Pending State**: "Download Invoice" generates a "Pro-forma" PDF (watermarked "UNPAID")
  - **Success State**: "Download Receipt" generates a Receipt PDF (watermarked "PAID", includes TxHash)

#### 12.6 Ambient Glow Spec: Network-Specific Lighting

**Technique**:
- Absolute positioned elements behind the invoice paper
- High blur radius: `blur-3xl` (~64px blur)
- Low opacity: `opacity-20` to `opacity-30` range
- Z-index MUST place glow behind paper but above desk background

**Colors by Network**:
- **Arbitrum**: Blue/Cyan gradient (`from-blue-500 to-cyan-500`)
- **Optimism**: Red/Orange gradient (`from-red-500 to-orange-500`)
- **Polygon**: Purple gradient (`from-purple-500 to-purple-600`)
- **Default/Ethereum**: Violet gradient (`from-violet-500 to-violet-600`)

**Implementation Requirements**:
- Glow MUST be subtle and not distract from invoice content
- Glow MUST NOT affect text readability on the white paper
- Glow color MUST update dynamically based on selected network
- Use CSS `mix-blend-mode` if needed to enhance effect without overwhelming

**Rationale**: The Hybrid Theme Strategy creates a strong visual metaphor that distinguishes the application chrome from the invoice document, reinforcing the stateless nature of the system (the "paper" exists independently of the "desk"). ISO 216 compliance ensures that what users see on screen matches what they'll get when printing or exporting to PDF, eliminating layout surprises.

### XIII. Serena-First Code Navigation & Tooling Priority

**Principle**: Agents MUST use Serena MCP symbolic tools as the PRIMARY method for code navigation, exploration, and editing. Direct file reading and text-based search tools are PROHIBITED for indexed languages (TypeScript, Markdown) except in explicitly permitted cases.

**Rules**:

#### 13.1 Mandatory Tool Priority Hierarchy

**Tier 1 - ALWAYS USE FIRST (Serena Symbolic Tools)**:
- `get_symbols_overview` - REQUIRED before reading any .ts/.tsx/.md file
- `find_symbol` - REQUIRED for locating functions/classes/types by name
- `find_referencing_symbols` - REQUIRED before editing any symbol
- `search_for_pattern` - For cross-file content search in indexed languages
- `replace_symbol_body` - For replacing entire functions/classes
- `insert_after_symbol` / `insert_before_symbol` - For adding code

**Tier 2 - FALLBACK ONLY (Non-Serena Tools)**:
- `Read` - ONLY permitted for: non-code files (.json, .yaml, .env.example, .lock files), binary files or generated files, files in languages NOT indexed by Serena (CSS, HTML, config files), AFTER using `get_symbols_overview` for small targeted edits within a symbol
- `Grep` - ONLY permitted for: languages not indexed by Serena (CSS, HTML, YAML, configs), literal string search in non-code files, NEVER for finding TypeScript/Markdown symbols
- `Glob` - ONLY permitted for: finding files by pattern when filename unknown, listing directory contents (Serena's `list_dir` preferred)

**Tier 3 - PROHIBITED**:
- ‚ùå Reading full .ts/.tsx/.md files without prior `get_symbols_overview`
- ‚ùå Using `Grep` to find TypeScript functions, classes, types, or interfaces
- ‚ùå Using `Grep` to search Markdown documentation files
- ‚ùå Editing symbols without `find_referencing_symbols` check
- ‚ùå Using `Read` + `Edit` for entire symbol replacement (use `replace_symbol_body`)

#### 13.2 Mandatory Workflows

**Code Exploration Workflow (REQUIRED)**:
```
1. get_symbols_overview(file) ‚Üí understand file structure
2. find_symbol(name_path, include_body=false) ‚Üí locate symbol
3. find_symbol(name_path, include_body=true) ‚Üí read implementation ONLY if needed
4. find_referencing_symbols(name_path) ‚Üí understand dependencies
```

**Code Editing Workflow (REQUIRED)**:
```
1. find_symbol ‚Üí locate symbol to edit
2. find_referencing_symbols ‚Üí check impact
3. replace_symbol_body OR insert_after/before_symbol ‚Üí apply changes
4. NEVER use Read + Edit for full symbol changes
```

**Cross-File Search Workflow**:
```
1. search_for_pattern (Serena) ‚Üí for TypeScript/Markdown content search
2. Grep ‚Üí ONLY if pattern not in indexed files
```

#### 13.3 Indexed Languages & Statistics

**Currently Indexed**:
- **TypeScript**: All .ts/.tsx files in src/ (production code)
- **Markdown**: 67+ files including `.specify/memory/*.md`, `specs/**/*.md`, `CLAUDE.md`, `README.md`

**Cache Location**: `.serena/cache/typescript/` and `.serena/cache/markdown/`

#### 13.4 Rationale

**Token Efficiency**: Reading full files wastes 10-100x tokens vs. targeted symbol reads.

**Semantic Understanding**: Language servers provide type information, definitions, and references that text search cannot. Grep finds strings; Serena finds symbols with full semantic context.

**Refactoring Safety**: `find_referencing_symbols` prevents breaking changes by showing all call sites before edits.

**Constitutional Alignment**: This principle supports Principle VIII (Documentation Context Efficiency) and Principle XIV (Serena Memory) by maximizing information density and minimizing redundant reads.

#### 13.5 Enforcement

- Agents MUST justify usage of Read/Grep on indexed files in commit messages
- Code reviews MUST flag violations as "inefficient tool usage"
- Constitutional compliance checks MUST verify Serena-first adherence

#### 13.6 Exceptions (Explicit Approval Required)

These cases require user approval before violating Serena-first:
1. Language server crashes or indexing failures
2. Serena MCP server unavailable/offline
3. Emergency debugging where speed > efficiency
4. Files explicitly excluded from indexing (gitignored, generated)

### XIV. Serena Memory as Project Knowledge Repository

**Principle**: Serena memory files (`.serena/memories/`) MUST serve as the PRIMARY source of truth for project-wide knowledge, architecture, and decisions. Agents MUST consult and update these memories to maintain project context efficiently.

**Rules**:

#### 14.1 Memory Consultation Requirements

- Agents MUST read relevant Serena memories BEFORE starting any feature work
- Agents MUST consult memories before reading extensive documentation or source code
- Memory reads MUST take priority over full file reads for understanding project architecture
- Memories provide the "what" and "why"; symbolic tools (Principle XIII) provide the "how"

#### 14.2 Memory Update Requirements

- Agents MUST update Serena memories when discovering new architectural patterns or decisions
- Agents MUST write new memories for major architectural decisions not yet documented
- Memory updates MUST happen at feature completion (alongside ROADMAP updates per Principle IX)
- Memories MUST be updated when existing documentation becomes stale or incomplete

#### 14.3 Memory Access (MCP Server Commands)

**MANDATORY**: Agents MUST use Serena MCP server tools (prefixed `mcp__serena__*`) for ALL memory operations. Direct file read/write to `.serena/memories/` is PROHIBITED.

**PROHIBITED**:
- ‚ùå Read(".serena/memories/architecture-summary.md") - Direct file access
- ‚ùå Write(".serena/memories/new-memory.md", ...) - Direct file write

**REQUIRED**:
- ‚úÖ Use `mcp__serena__*` tools for all memory operations
- ‚úÖ List available memories before reading
- ‚úÖ Write/update memories at feature completion

#### 14.4 Memory Content Guidelines

- Memory files MUST be information-dense following Principle VIII guidelines
- Memories MUST NOT duplicate content from SpecKit artifacts (`specs/###-feature/`)
- Memories capture project-level knowledge; SpecKit captures feature-level design
- Use structured formats (lists, tables, code blocks) over narrative prose
- Maximum memory length target: <300 lines (exceptions for complex architecture docs)

#### 14.5 Source of Truth Hierarchy

1. **Constitution** (`.specify/memory/constitution.md`) - Governance & non-negotiable principles
2. **Serena Memories** (`.serena/memories/`) - Architecture, patterns, tech stack, decisions
3. **SpecKit Artifacts** (`specs/###-feature/`) - Feature-specific design (spec, plan, tasks)
4. **Source Code** - Implementation reality (ultimate source of truth)

When conflicts arise, higher levels override lower levels (Constitution > Memories > SpecKit > Code implies code should change).

#### 14.6 Standard Memory Categories

**Required Memories** (MUST exist for all projects):
- `project-overview` - High-level project description, philosophy, core value proposition
- `tech-stack-locked` - Locked technology versions and update policy
- `architecture-summary` - Project structure (e.g., FSD layers), routing, data flow
- `constitutional-principles-summary` - Quick reference to all principles (this file distilled)
- `development-status` - Current roadmap progress, active features, blockers

**Optional Memories** (create as needed):
- `<feature-area>-architecture` - Deep dive on specific architectural domain (e.g., `payment-verification-architecture`)
- `<decision-name>-decision` - Major architectural decisions with rationale (e.g., `rpc-proxy-decision`)
- `<pattern-name>-pattern` - Reusable patterns (e.g., `state-management-pattern`)

#### 14.7 Integration with Other Principles

- **Principle VIII (Context Efficiency)**: Memories prevent re-reading verbose documentation
- **Principle XIII (Serena-First)**: Memories provide architecture context; symbolic tools provide code context
- **Principle IX (Deviation Tracking)**: Memories updated when deviations reveal architectural changes
- **Principle XV (SpecKit)**: Memories provide project context before creating specs/plans

#### 14.8 Workflow Integration

**Feature Start Workflow (REQUIRED)**:
```
1. Read relevant Serena memories (architecture, tech stack, principles)
2. Launch /speckit.specify with context from memories
3. During /speckit.plan: Reference memories for architectural constraints
4. During /speckit.implement: Update memories if new patterns discovered
```

**Memory Update Workflow**:
```
1. Feature completion triggers memory review
2. If new architectural patterns emerged ‚Üí write new memory or update existing
3. If tech stack changed ‚Üí update tech-stack-locked memory
4. If roadmap milestone reached ‚Üí update development-status memory
```

#### 14.9 Anti-Patterns (VIOLATIONS)

**VIOLATION #1: Starting feature without reading memories**
```
‚ùå /speckit.specify "Add payment feature" without reading architecture-summary  // WRONG
‚úÖ read_memory("architecture-summary") ‚Üí understand FSD layers ‚Üí /speckit.specify  // CORRECT
```

**VIOLATION #2: Duplicating memory content in SpecKit artifacts**
```
‚ùå Copy entire tech stack list into specs/005-feature/plan.md  // WRONG
‚úÖ Reference "See tech-stack-locked memory" in plan.md  // CORRECT
```

**VIOLATION #3: Discovering major decision without writing memory**
```
‚ùå Implement new state pattern, complete feature, never document  // WRONG
‚úÖ Implement pattern ‚Üí write state-management-pattern memory ‚Üí update architecture-summary  // CORRECT
```

#### 14.10 Rationale

**Token Efficiency**: Without memories, agents waste thousands of tokens re-reading the same architectural documentation for every feature. A 200-line memory prevents reading 2000+ lines of scattered documentation.

**Knowledge Preservation**: As the project evolves, architectural decisions get lost in commit history or outdated documentation. Memories create a living knowledge base that compounds over time.

**Onboarding Efficiency**: New agents (or agent sessions) can quickly understand the project by reading 5-10 memory files instead of exploring dozens of source files.

**Layered Knowledge System**: Constitution (principles) ‚Üí Memories (architecture) ‚Üí Symbols (code navigation) ‚Üí Files (implementation details). Each layer filters and concentrates knowledge for the next.

#### 14.11 Enforcement

- Agents MUST justify NOT consulting memories when starting features
- Code reviews SHOULD verify memory updates for features introducing new patterns
- Constitutional compliance checks MUST verify memories exist and are up-to-date

### XV. SpecKit Workflow Compliance

**Principle**: All feature development MUST follow the SpecKit workflow (`/speckit.specify` ‚Üí `/speckit.plan` ‚Üí `/speckit.tasks` ‚Üí `/speckit.implement`) with structured artifacts in `specs/###-feature/` directories. Ad-hoc feature development without this workflow is PROHIBITED.

**Rules**:

#### 15.1 Workflow Phases (MANDATORY)

**Phase 1: Specification** (`/speckit.specify <description>`):
- Creates `specs/###-feature/spec.md` with user stories and requirements
- User stories MUST be prioritized (P1, P2, P3) and independently testable
- Generates feature branch (`###-feature-name`)
- Creates Git worktree (`worktrees/###-feature-name`) per Principle X
- Output: spec.md with clear acceptance criteria

**Phase 2: Planning** (`/speckit.plan`):
- Creates `specs/###-feature/plan.md` with technical approach
- Includes Constitution Check (validates all 15 principles)
- Documents research in `research.md` (exploration findings)
- Documents data model in `data-model.md` (schema, entities)
- Creates API contracts in `contracts/` if applicable (endpoints, interfaces)
- Consults Serena memories per Principle XIV before planning
- Output: plan.md, research.md, data-model.md, contracts/ (as needed)

**Phase 3: Tasks Generation** (`/speckit.tasks`):
- Creates `specs/###-feature/tasks.md` with dependency-ordered tasks
- Tasks organized by user story for independent delivery
- Includes parallel execution markers ([P] for parallelizable tasks)
- Includes deviation tracking format per Principle IX
- Output: tasks.md with executable task list

**Phase 4: Implementation** (`/speckit.implement`):
- Executes tasks from tasks.md in feature worktree
- Tracks deviations from plan in tasks.md
- Updates ROADMAP upon completion per Principle IX
- Updates Serena memories if new patterns discovered per Principle XIV
- Output: Working feature, updated ROADMAP, updated memories

#### 15.2 Artifact Requirements

**Directory Structure**:
- All artifacts MUST reside in `specs/###-feature/` (feature number padded to 3 digits: 001, 002, etc.)
- Feature folder name MUST match Git branch name (`###-feature-name`)
- Example: `specs/005-payment-verification/` with branch `005-payment-verification`

**Mandatory Artifacts**:
- `spec.md` - User stories, requirements, success criteria (from /speckit.specify)
- `plan.md` - Technical approach, Constitution Check, complexity tracking (from /speckit.plan)
- `tasks.md` - Dependency-ordered task list (from /speckit.tasks)

**Optional Artifacts** (created by /speckit.plan as needed):
- `research.md` - Exploration findings, external resource links
- `data-model.md` - Schema definitions, entity relationships
- `contracts/` - API contracts, interface definitions
- `quickstart.md` - Setup instructions for the feature

**Artifact Lifecycle**:
- Artifacts MUST NOT be committed to main branch until feature completion
- Artifacts committed in feature worktree during development
- Artifacts merged to main upon feature completion and ROADMAP update
- Completed feature folders serve as historical design documentation

#### 15.3 Compliance Requirements

**MANDATORY Rules**:
- Agents MUST NOT skip phases (no implementation without planning)
- Agents MUST NOT create features outside SpecKit workflow
- Agents MUST NOT directly edit main branch for features (use worktrees per Principle X)
- Agents MUST validate Constitution Check in plan.md before proceeding to tasks

**Permitted Exceptions** (require explicit justification):
- Emergency bug fixes (security vulnerabilities, production incidents)
- Trivial changes (typo fixes, comment updates, formatting)
- Infrastructure maintenance (dependency updates, tooling upgrades)

Exception justification MUST include:
- Why SpecKit workflow was bypassed
- What risk this poses to Constitutional compliance
- What compensating controls are in place

#### 15.4 Integration with Other Principles

**Principle IX (Deviation Tracking)**:
- Deviation tracking happens in tasks.md during `/speckit.implement`
- Format: `- [x] T001 [Description] | Deviation: [None | <deviation description>]`
- Accumulated deviations reviewed at feature completion

**Principle X (Git Worktree Isolation)**:
- Worktrees created automatically during `/speckit.specify`
- Each feature isolated in `worktrees/###-feature-name/`
- Main worktree reserved for integration only

**Principle VIII (Context Efficiency)**:
- All SpecKit artifacts follow information-dense formatting
- spec.md focuses on requirements, not implementation details
- plan.md focuses on technical approach, not step-by-step instructions
- Avoid verbose prose; use structured formats (lists, tables, code blocks)

**Principle XIV (Serena Memory)**:
- Consult Serena memories before creating spec.md (understand architecture)
- Consult memories before planning (understand constraints)
- Update memories after implementation if new patterns discovered

**Constitution Check in plan.md validates all 15 principles**:
- Principle I: Zero-Backend (no server database)
- Principle II: Privacy-First (no analytics)
- Principle III: Permissionless (no auth)
- Principle IV: Schema Versioning (no breaking changes)
- Principle V: Security (blocklist, abuse prevention)
- Principle VI: RPC Protection (proxy, failover)
- Principle VII: Web3 Safety (decimals, finality)
- Principle VIII: Context Efficiency (concise artifacts)
- Principle IX: Deviation Tracking (implemented in tasks.md)
- Principle X: Worktree Isolation (feature developed in worktree)
- Principle XI: Design Fidelity (V0 assets used)
- Principle XII: UI/UX Principles (Hybrid Theme, A4 ratio)
- Principle XIII: Serena-First Navigation (symbolic tools used)
- Principle XIV: Memory Consultation (memories read before planning)
- Principle XV: SpecKit Workflow (this workflow followed)

#### 15.5 Workflow Benefits

**Audit Trail**: Complete history of feature development (why ‚Üí how ‚Üí what)
- spec.md: Why (user needs, requirements)
- plan.md: How (technical approach, architecture)
- tasks.md: What (implementation steps)
- Source code: Reality (actual implementation)

**Constitutional Compliance**: Constitution Check in plan.md ensures every feature validates all 15 principles before implementation

**Knowledge Preservation**: Design decisions captured in artifacts, not lost in commits or memory

**Parallel Development**: Multiple agents can work on different features simultaneously (each in isolated worktree)

**Independent Delivery**: User stories prioritized and independently testable enables incremental delivery

#### 15.6 Anti-Patterns (VIOLATIONS)

**VIOLATION #1: Skipping phases**
```
‚ùå User: "Add payment feature" ‚Üí Agent: implements directly in main branch  // WRONG
‚úÖ /speckit.specify ‚Üí /speckit.plan ‚Üí /speckit.tasks ‚Üí /speckit.implement  // CORRECT
```

**VIOLATION #2: Ad-hoc feature development**
```
‚ùå Create feature files directly in src/ without specs/ artifacts  // WRONG
‚úÖ Follow SpecKit workflow ‚Üí all design artifacts in specs/###-feature/  // CORRECT
```

**VIOLATION #3: Incomplete Constitution Check**
```
‚ùå plan.md Constitution Check validates only Principles I-III  // WRONG
‚úÖ plan.md Constitution Check validates ALL 15 principles  // CORRECT
```

**VIOLATION #4: Feature artifacts on main branch**
```
‚ùå Commit specs/006-feature/ to main before feature completion  // WRONG
‚úÖ Develop in worktree ‚Üí merge to main only when feature complete  // CORRECT
```

#### 15.7 Rationale

**Prevents Ad-Hoc Development**: Without enforced workflow, features are developed inconsistently. Some skip planning, others skip requirements. This leads to Constitutional violations and technical debt.

**Ensures Constitutional Compliance**: Constitution Check in plan.md forces validation of all 15 principles before any code is written. This prevents expensive rework when violations discovered late.

**Creates Institutional Knowledge**: SpecKit artifacts serve as historical documentation. When revisiting a feature months later, specs/###-feature/ contains the complete context: why it was built, how it was designed, what changed during implementation.

**Enables Parallel Development**: With structured workflows and isolated worktrees, multiple agents can work on different features without conflicts or coordination overhead.

**Supports Incremental Delivery**: User stories prioritized (P1, P2, P3) and independently testable enables shipping P1 as MVP, then adding P2/P3 incrementally.

#### 15.8 Enforcement

- Agents MUST reject requests to implement features without SpecKit workflow
- Code reviews MUST verify specs/###-feature/ artifacts exist and are complete
- Constitutional compliance checks MUST verify Constitution Check in plan.md validates all 15 principles
- ROADMAP updates MUST reference Feature Folder (proves SpecKit workflow was followed)

#### 15.9 Emergency Exception Protocol

When bypassing SpecKit workflow for emergencies:

1. Create GitHub issue documenting: emergency nature, Constitutional principles affected, compensating controls
2. Implement fix directly on main branch
3. Retrospectively create specs/###-emergency-fix/ with spec.md and plan.md documenting what was done and why
4. Update ROADMAP with emergency feature folder reference
5. Review in next planning session: could this have been prevented? Do we need new Constitutional safeguards?

**Examples of valid emergencies**:
- Security vulnerability requiring immediate patch
- Production incident causing service disruption
- Critical bug affecting user funds or data integrity

**Examples of invalid emergencies** (MUST use SpecKit):
- "Urgent" feature request from stakeholder
- Missed deadline (poor planning, not emergency)
- "Quick fix" that bypasses Constitution Check

## Architectural Constraints

### Technology Stack (Locked for MVP)

The following technology choices are locked for MVP to ensure consistency and maintainability. See Serena memory `tech-stack-locked` for detailed version information.

**Core Framework**:
- Next.js 15+ (App Router + Edge Runtime)
- React 18+
- TypeScript 5.x+ (strict mode)
- Node.js 20+ (specified in .nvmrc)

**Web3 Stack**:
- Wagmi v2+ (Web3 core)
- Viem v2+ (Ethereum interactions)
- RainbowKit v2+ (wallet UI)
- Alchemy + Infura (RPC providers)

**State & Data**:
- Zustand 5+ (client state)
- TanStack Query v5+ (async data, caching)
- lz-string 1.5.0+ (URL compression)

**UI & Styling**:
- Tailwind CSS 4+
- shadcn/ui (Radix UI components)
- Lucide React (latest - icons)

**Supported Networks (MVP)**:
- Ethereum Mainnet (Chain ID: 1)
- Arbitrum (Chain ID: 42161)
- Optimism (Chain ID: 10)
- Polygon PoS (Chain ID: 137)

**Version Update Policy**:
- Minor and patch updates are permitted for all dependencies
- Major version updates require constitutional amendment and migration plan
- Security patches should be applied immediately

### Project Structure (Feature-Sliced Design)

The application MUST follow Feature-Sliced Design (FSD) architecture. See Serena memory `architecture-summary` for detailed structure.

**Layers** (from highest to lowest):
- `app/` - Routing and application initialization
- `pages/` - Page composition
- `widgets/` - Large UI blocks
- `features/` - User interactions and actions
- `entities/` - Business logic and domain models
- `shared/` - Utilities and UI primitives

**Routing**:
- `/` - Marketing landing page (SEO optimized, indexed)
- `/create` - Invoice editor (client-heavy, noindex)
- `/pay` - Payment view (dynamic, noindex)

### Data Model Constraints

**Invoice Schema (v1)** - The following fields are locked (see specs/002-url-state-codec/ for full specification):

```typescript
interface InvoiceSchemaV1 {
  v: number;        // Version (always 1 for v1)
  id: string;       // Invoice ID
  iss: string;      // Issue Date (ISO 8601)
  due: string;      // Due Date (ISO 8601)
  nt?: string;      // Notes (max 280 chars - HARD LIMIT)
  net: number;      // Chain ID
  cur: string;      // Currency Symbol
  t?: string;       // Token Address (undefined = native)
  dec: number;      // Token decimals (MANDATORY - baked in)
  f: {...};         // Sender info
  c: {...};         // Client info
  it: [...];        // Line items
  tax: string;      // Tax rate
  dsc: string;      // Discount amount
}
```

**URL Constraints**:
- Maximum compressed URL length: 2000 bytes
- Compression algorithm: lz-string (LZW)
- Generation MUST be blocked if URL exceeds limit
- Notes field MUST be limited to 280 characters (enforced in UI)

**Magic Dust Verification**:
- Random micro-amount added to each invoice: 0.000001 - 0.000999
- Provides unique identifier for exact payment matching
- NO fuzzy matching or tolerance - exact amount match required

## Security & Risk Management

### Abuse Management

**Static Blocklist Implementation**:
- Source: `https://raw.githubusercontent.com/voidpay/blocklist/main/blocked-hashes.json`
- Format: `{ "hashes": ["sha256_1", ...], "updated": "ISO8601_timestamp" }`
- Hash target: Full URL parameter `?d=...` (not invoice contents)
- Update mechanism: Public Pull Request to blocklist repository
- UI behavior: Red blocking screen for flagged URLs
- Reporting: "Report Abuse" button generates GitHub issue/PR

**Privacy Preservation**:
- Hashes prevent exposure of invoice contents
- Public blocklist ensures transparency
- Community moderation via GitHub

### Risk Mitigation Matrix

**Technical Risks**:
- RPC key leak ‚Üí Serverless proxy with env variables
- RPC rate limits ‚Üí Multi-provider failover + aggressive caching
- Browser storage wipe ‚Üí Export/import JSON functionality
- URL length overflow ‚Üí Hard limits + validation + short JSON keys
- Schema breaking ‚Üí Strict versioning + migration adapters

**UX Risks**:
- Partial payments ‚Üí Display "Partially Paid" status with progress bar
- Fee-on-transfer tokens ‚Üí Warning labels
- In-app browsers ‚Üí Detect and show "Open in system browser" prompt

**Legal/Compliance Risks**:
- OFAC sanctions ‚Üí NOT implemented in MVP (permissionless philosophy)
- Domain blacklisting ‚Üí Static blocklist + noindex meta tags
- Support liability ‚Üí Explicit disclaimers ("non-custodial interface")

### Non-Negotiable Security Requirements

- All transaction amounts MUST use exact precision (no floating point)
- Wallet addresses MUST be validated (checksum + visual confirmation via avatar)
- Network IDs MUST be validated against supported list
- Token contracts MUST be validated against token list or show warnings
- All user-facing errors MUST NOT expose internal system details
- All external links MUST open in new tab with `rel="noopener noreferrer"`

## Governance

### Amendment Process

**This Constitution supersedes all other project practices and guidelines.**

Changes to this Constitution require:

1. **Documentation**: Proposed amendment in GitHub issue with rationale
2. **Impact Analysis**: Review of affected templates, code, and user experience
3. **Version Bump Decision**:
   - MAJOR: Backward incompatible changes (principle removal/redefinition)
   - MINOR: New principles or materially expanded guidance
   - PATCH: Clarifications, typo fixes, non-semantic refinements
4. **Template Updates**: All dependent templates (.specify/templates/) updated
5. **Memory Updates**: Serena memories updated to reflect Constitutional changes (Principle XIV)
6. **Sync Report**: HTML comment at top of constitution documenting changes
7. **Approval**: Project maintainer approval required

### Compliance Review

**All feature specifications and implementation plans MUST verify compliance with all 15 Constitutional Principles:**

- I: Zero-Backend Architecture
- II: Privacy-First & Self-Custody
- III: Trustless & Permissionless
- IV: Backward Compatibility & Schema Versioning
- V: Security & Abuse Prevention
- VI: RPC Key Protection & Rate Limit Management
- VII: Web3 Safety & Transaction Validation
- VIII: Documentation Context Efficiency
- IX: Implementation Deviation Tracking & Feedback Loop
- X: Git Worktree Isolation for Concurrent Development
- XI: Design Fidelity & V0 Integration
- XII: UI/UX Design Principles
- XIII: Serena-First Code Navigation & Tooling Priority
- XIV: Serena Memory as Project Knowledge Repository
- XV: SpecKit Workflow Compliance

**Constitution Check Gate** in plan-template.md MUST verify:

- No backend database introduced (I)
- No user authentication/registration added (III)
- Schema changes follow versioning rules (IV)
- New features preserve privacy-first approach (II)
- Security mechanisms not bypassed (V)
- Documentation follows context efficiency guidelines (VIII)
- UI follows Hybrid Theme Strategy: dark desk, light paper (XII)
- Document representations maintain ISO 216 (A4) aspect ratio (XII)
- All TypeScript/Markdown navigation uses Serena tools first (XIII)
- Serena memories consulted before planning (XIV)
- Following SpecKit workflow phases (XV)

### Complexity Justification

Any violation of Constitutional principles MUST be explicitly justified in the "Complexity Tracking" section of plan.md with:

- Which principle is violated
- Why the violation is necessary
- What simpler alternatives were rejected and why

**Examples requiring justification**:
- Introducing server-side session storage (violates Principle I)
- Adding Google Analytics (violates Principle II)
- Requiring email verification (violates Principle III)
- Changing URL compression algorithm without migration (violates Principle IV)
- Writing verbose 800-line specification documents (violates Principle VIII)
- Using Read/Grep for TypeScript code navigation (violates Principle XIII)
- Skipping Serena memory consultation (violates Principle XIV)
- Implementing feature without SpecKit workflow (violates Principle XV)

### Development Philosophy

**Start Simple, Stay Simple**:
- YAGNI (You Aren't Gonna Need It) - No speculative features
- Every feature must have clear user value from brainstorm/spec
- Prefer boring, proven technologies over cutting-edge
- Optimize for maintainability over cleverness

**Testing Discipline**:
- Schema versioning MUST have integration tests (old URLs must work)
- Payment verification logic MUST have unit tests
- URL compression/decompression MUST have round-trip tests
- Multi-network support MUST have integration tests per network

**Observability Without Telemetry**:
- Text I/O ensures debuggability (console logs in dev)
- Error messages must be actionable for users
- NO error tracking services (violates Privacy principle)
- Debug mode via URL parameter for troubleshooting

**Documentation Standards** (Principle VIII):
- Prefer information density over exhaustive explanation
- Use structured formats (tables, lists) over narrative prose
- Document decisions and rationale, not implementation steps
- Keep specs focused on requirements, plans focused on approach
- Link to external resources rather than duplicating content

**Code Navigation Standards** (Principle XIII):
- Always use Serena symbolic tools for TypeScript/Markdown exploration
- Never read full files without `get_symbols_overview` first
- Check references with `find_referencing_symbols` before editing
- Use `replace_symbol_body` for function/class replacements
- Reserve Read/Grep for non-indexed files only

**Knowledge Management Standards** (Principle XIV):
- Consult Serena memories before starting any feature work
- Update memories when discovering new architectural patterns
- Maintain memory hierarchy: Constitution > Memories > SpecKit > Code
- Keep memories information-dense and up-to-date

**Workflow Standards** (Principle XV):
- Follow SpecKit workflow for all features: specify ‚Üí plan ‚Üí tasks ‚Üí implement
- Validate Constitution Check in plan.md before proceeding to implementation
- Track deviations in tasks.md during implementation
- Update ROADMAP and memories upon feature completion

**Version**: 1.9.0 | **Ratified**: 2025-11-19 | **Last Amended**: 2025-11-28
